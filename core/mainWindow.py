import os
from PyQt6 import QtWidgets, uic, QtCore, QtGui


# from sr830.sr830_main import SR830
# from sr860.sr860_main import SR860
# from nidaq.nidaq_main import NIDAQ
# from keithley24xx.keithley24xx_main import Keithley24xx
# from k10cr1.k10cr1_main import K10CR1
# from tlpm.tlpm_main import TLPM

from .scan_info import *
from .scanlist import ScanList
from .artificial_channel_logic import ArtificialChannelLogic
from .artificial_channel_2d_main import ArtificialChannel2D


#Select Virtual Environment under zmeter_venv\.venv\Scripts\python.exe
class MainWindow(QtWidgets.QWidget):
    print("Initiating the Program")
    def __init__(self, info=None, save_path=None, backup_main_path=None, equips=None):
        super().__init__()
        print("Loading the Main Window")
        uic.loadUi(r"core/ui/mainwindow.ui", self)
        self.info = info
        
        # ------------------------------------------------------------
        # Configuration previously hard-coded here is now supplied via
        # the constructor arguments so that users can customise the
        # application without editing this file.  See `start_zmeter.py`.

        # Paths
        if save_path is None:
            save_path = os.path.join(os.getcwd(), "data")
        self.save_path = save_path

        if backup_main_path is None:
            self.backup_bool = False
        else:
            self.backup_bool = True
            self.backup_main_path = backup_main_path

        # Reflect the paths in the UI elements that were generated by
        # QtDesigner.
        self.ppt_path.setPlainText(os.path.join(self.save_path, "log.pptx"))
        self.save_info_path.setPlainText(self.save_path)

        if self.backup_bool:
            self.backup_path = os.path.join(
                self.backup_main_path, os.path.basename(os.getcwd())
            )
            self.backup_Path.setPlainText(self.backup_path)

        # Equipment instances (already connected) provided by caller.
        # Fall back to an empty dict for headless usage/testing.
        self.equips = equips if equips is not None else {}
        # ------------------------------------------------------------

        # {equipment name (e.g. lockin_0) : {variable name : set method},....}
        self.setter_equipment_info_for_scanning = {}
        # {equipment name (e.g. lockin_0) : {variable name : get method},....}
        self.getter_equipment_info_for_scanning = {}
        # {equipment(lockin_0) : [list of variable name]}
        self.setter_equipment_info = {}
        # {equipment : [list of variable name]}
        self.getter_equipment_info = {}

        self.make_equipment_info()
        self.setup_artificial_channel_info()

        self.scanlist = ScanList(
            info=self.info,
            setter_equipment_info=self.setter_equipment_info,
            main_window=self,
            getter_equipment_info=self.getter_equipment_info,
        )
        self.scanlist.show()
        self.scanlist.setWindowTitle("Scan List")
        self.scan_list_button.clicked.connect(self.scanlist.show)
        self.update_serial_counter()              # set it once on start-up

        self.open_equipment_buttons = []
        for equipment_name, equipment in self.equips.items():
            # equipment.show()
            equipment.setWindowTitle(equipment_name)
            open_button = QtWidgets.QPushButton()
            open_button.setText(equipment_name)
            self.open_equipment_buttons.append(open_button)
            self.open_button_layout.addWidget(open_button)
            open_button.clicked.connect(equipment.show)

    # artificial channels

    def setup_artificial_channel_info(self):
        self.artificial_channel_logic = ArtificialChannelLogic(
            write_channel=self.write_info,
            read_channel=self.read_info,
            parent=self,
            original_channel_x_limits=(-1.0, 1.0),
            original_channel_y_limits=(-1.0, 1.0),
        )
        self.update_artificial_channel_scan_info()

        self.artificial_channel_2d = ArtificialChannel2D(
            logic=self.artificial_channel_logic,
            setter_equipment_info=self.setter_equipment_info,
            on_config_applied=self.on_artificial_channel_config_applied,
            parent=None,
        )

        self.open_artificial_channel_button = QtWidgets.QPushButton(
            "artificial channel 2D"
        )
        self.open_button_layout.addWidget(self.open_artificial_channel_button)
        self.open_artificial_channel_button.clicked.connect(
            self.open_artificial_channel_2d_window
        )

    def open_artificial_channel_2d_window(self):
        self.artificial_channel_2d.show()
        self.artificial_channel_2d.raise_()
        self.artificial_channel_2d.activateWindow()

    def update_artificial_channel_scan_info(self):
        self.equations = dict(self.artificial_channel_logic.equations)
        self.setter_equipment_info["artificial_channel"] = list(
            self.artificial_channel_logic.artificial_channels
        )
        self.getter_equipment_info["artificial_channel"] = list(
            self.artificial_channel_logic.artificial_channels
        )
        self.setter_equipment_info["default"] = ["count", "wait"]

    def on_artificial_channel_config_applied(self):
        self.update_artificial_channel_scan_info()
        if hasattr(self, "scanlist"):
            self.scanlist.setter_equipment_info_updated(self.setter_equipment_info)
            self.scanlist.getter_equipment_info_updated(self.getter_equipment_info)

    def write_artificial_channel(self, val, variable):
        self.artificial_channel_logic.set_channel_value(variable, val)

    def read_artificial_channel(self, variable):
        return self.artificial_channel_logic.read_channel_value(variable)

    ## Adding devices and make equipment info

    def make_equipment_info(self):
        for key, equipment in self.equips.items():

            set_variable, get_variable = self.make_variables_dictionary(equipment)

            self.setter_equipment_info_for_scanning[key] = set_variable
            self.getter_equipment_info_for_scanning[key] = get_variable

            self.setter_equipment_info[key] = list(set_variable.keys())
            self.getter_equipment_info[key] = list(get_variable.keys())

    def make_variables_dictionary(self, equipment):
        get_variables = {}
        set_variables = {}
        get_methods = [
            method
            for method in dir(equipment.logic)
            if callable(getattr(equipment.logic, method))
        ]  ###################################
        set_methods = [
            method
            for method in dir(equipment.logic)
            if callable(getattr(equipment.logic, method))
        ]
        for method in get_methods:
            if method.startswith("get_"):
                var_name = method[4:]
                get_variables[var_name] = getattr(equipment.logic, method)
        for method in set_methods:
            if method.startswith("set_"):
                var_name = method[4:]
                set_variables[var_name] = getattr(equipment.logic, method)
        return set_variables, get_variables

    def execute_default(self, val, master):
        """
        Execute default functions 
        wait - sleep for the giving second
        count - repeat the scan
        """
        for index, character in enumerate(master):
            if character == "_":
                variable = master[index + 1 : :]
        if variable == "wait":
            time.sleep(val)
        elif variable == "count":
            time.sleep(0.01)


    # Read and write info

    # def write_info(self, val, master):
    #     if np.isnan(val):
    #         return
    #     for key, equipment in self.setter_equipment_info_for_scanning.items():
    #         if key in master:  # key = lockin_0  master = lockin_0_amplitude
    #             time.sleep(0.01)
    #             variable = self.get_variable(master)
    #             equipment[variable](val)

    def write_info(self, val, master):
        if np.isnan(val):
            return

        for label, setters in self.setter_equipment_info_for_scanning.items():
            # exact prefix match: label followed by an underscore
            if master.startswith("default_"):
                print("here")
                self.execute_default(val, master)
            elif master.startswith(f"{label}_"):
                variable = self.get_variable(master, label)
                try:
                    setters[variable](val)
                except KeyError:
                    raise KeyError(
                        f"Variable '{variable}' not found in equipment '{label}'. "
                        f"Check your channel name '{master}'."
                    )
                break

    # def get_variable(self, name):
    #     counter = False
    #     for index, character in enumerate(name):
    #         if character == "_":
    #             if counter:
    #                 return name[index + 1 : :]
    #             else:
    #                 counter = True
    
    def get_variable(self, full_name: str, equip_label: str) -> str:
        """
        Given a full channel name like 'nidaq_0_voltage'
        and its equipment label 'nidaq_0', return 'voltage'.
        Works for labels that contain zero-or-many underscores.
        """
        prefix = f"{equip_label}_"
        return full_name[len(prefix):]   # everything after the prefix

    # def read_info(self, slave):

    #     if slave == "none":
    #         result = np.nan
    #     else:
    #         for key, equipment in self.getter_equipment_info_for_scanning.items():
    #             if key in slave:
    #                 variable = self.get_variable(slave)
    #                 result = equipment[variable]()
    #             # result=equipment.read_info(slave[-1])

    #     return result

    def read_info(self, slave):
        if slave == "none":
            return np.nan

        for label, getters in self.getter_equipment_info_for_scanning.items():
            if slave.startswith(f"{label}_"):
                variable = self.get_variable(slave, label)
                return getters[variable]()        # return the read value

        raise KeyError(f"No equipment found that matches channel '{slave}'.")
    
    
    _serial_regex = re.compile(r"^(\d{4})_")      # “0000_ …”

    def _serial_folder(self) -> str:
        """
        Folder in which data files are stored, trimmed & normalised.
        Falls back to cwd if the text box is empty.
        """
        txt = ""
        if hasattr(self, "save_info_path"):
            if callable(getattr(self.save_info_path, "toPlainText", None)):
                txt = self.save_info_path.toPlainText()
            elif callable(getattr(self.save_info_path, "text", None)):
                txt = self.save_info_path.text()

        txt = txt.strip().strip('"')
        return os.path.normpath(txt) if txt else os.getcwd()

    def update_serial_counter(self):
        """
        Look at existing files and set ScanList.serial accordingly.
        """
        folder = self._serial_folder()
        if not os.path.isdir(folder):
            self.scanlist.serial.setValue(0)
            return

        max_found = -1
        for fname in os.listdir(folder):
            m = self._serial_regex.match(fname)
            if m:
                num = int(m.group(1))
                if num > max_found:
                    max_found = num

        self.scanlist.serial.setValue(max_found + 1 if max_found >= 0 else 0)

    def stop_equipments_for_scanning(self):
        # need fix
        for name, equipment in self.equips.items():
            if hasattr(equipment, "stop_scan"):
                equipment.stop_scan()

    def start_equipments(self):
        for name, equipment in self.equips.items():
            if hasattr(equipment, "start_scan"):
                equipment.start_scan()

    def force_stop_equipments(self):
        for name, equipment in self.equips.items():
            if hasattr(equipment, "force_stop"):
                equipment.force_stop()


    def closeEvent(self, event: QtGui.QCloseEvent):          # <- keep the type
        reply = QtWidgets.QMessageBox.question(
            self,
            "Confirm Exit",
            "Quit the application and disconnect all equipment?",
            QtWidgets.QMessageBox.StandardButton.Yes
            | QtWidgets.QMessageBox.StandardButton.No,
            QtWidgets.QMessageBox.StandardButton.No,         # default = “No”
        )

        if reply == QtWidgets.QMessageBox.StandardButton.Yes:
            # proceed with the regular shutdown
            if hasattr(self, "artificial_channel_2d"):
                self.artificial_channel_2d.close()
            self.scanlist.shutdown()
            self.force_stop_equipments()
            self.stop_equipments_for_scanning()
            for equipment_name, equipment in self.equips.items():
                print("Terminating", equipment_name)
                equipment.terminate_dev()
                equipment.close()
            print("Main Window terminated.")
            event.accept()                                   # actually close
        else:
            event.ignore()                                   # stay open

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = MainWindow(info=ScanInfo)
    window.show()
    window.setWindowTitle("Main Window")
    app.exec()
